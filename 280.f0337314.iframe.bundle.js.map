{"version":3,"file":"280.f0337314.iframe.bundle.js","mappings":";;;;;;;;;AAAA;ACCA;;AAEA;;;;;AAKA;;;;;;ACiEA;;AAsNA;;;;AC5NA;ACwCA;;;;ACZA;AACA;;;;AAUA;;AA4SA;;;ACvYA;;;;;AAKA;;;AAGA;AACA;;;;;AAKA;AAxBA;;;AAGA;AACA;;;AAGA;;;;AARA;;;;AA6BA","sources":["webpack://@raidguild/design-system/./node_modules/@storybook/addon-actions/dist/preview.mjs","webpack://@raidguild/design-system/./node_modules/@storybook/client-api/dist/index.mjs","webpack://@raidguild/design-system/./node_modules/@storybook/preview-web/dist/esm/Preview.js","webpack://@raidguild/design-system/./node_modules/@storybook/preview-web/dist/esm/parseArgsParam.js","webpack://@raidguild/design-system/./node_modules/@storybook/preview-web/dist/esm/WebView.js","webpack://@raidguild/design-system/./node_modules/@storybook/preview-web/dist/esm/PreviewWeb.js","webpack://@raidguild/design-system/./node_modules/@storybook/store/dist/index.mjs"],"sourcesContent":["import{h as g,j as p}from\"./chunk-FEZISCVM.mjs\";var T=[p];var A=(e,t)=>typeof t[e]>\"u\"&&!(e in t),y=e=>{let{initialArgs:t,argTypes:n,parameters:{actions:s}}=e;if(!s||s.disable||!s.argTypesRegex||!n)return{};let c=new RegExp(s.argTypesRegex);return Object.entries(n).filter(([r])=>!!c.test(r)).reduce((r,[o,m])=>(A(o,t)&&(r[o]=g(o)),r),{})},f=e=>{let{initialArgs:t,argTypes:n,parameters:{actions:s}}=e;return s?.disable||!n?{}:Object.entries(n).filter(([i,r])=>!!r.action).reduce((i,[r,o])=>(A(r,t)&&(i[r]=g(typeof o.action==\"string\"?o.action:r)),i),{})};var F=[f,y];export{F as argsEnhancers,T as decorators};\n","import{dedent as L}from\"ts-dedent\";import N from\"global\";import{logger as b}from\"@storybook/client-logger\";import{toId as z,sanitize as V}from\"@storybook/csf\";import{combineParameters as T,composeStepRunners as Y,normalizeInputTypes as I}from\"@storybook/store\";import k from\"global\";import{dedent as G}from\"ts-dedent\";import{SynchronousPromise as $}from\"synchronous-promise\";import{toId as x,isExportStory as v,storyNameFromExport as M}from\"@storybook/csf\";import{userOrAutoTitle as _,sortStoriesV6 as C}from\"@storybook/store\";import{logger as D}from\"@storybook/client-logger\";var A=class{constructor(){this.projectAnnotations={loaders:[],decorators:[],parameters:{},argsEnhancers:[],argTypesEnhancers:[],args:{},argTypes:{}},this.entries={},this.csfExports={}}importFn(r){return $.resolve().then(()=>{let t=this.csfExports[r];if(!t)throw new Error(`Unknown path: ${r}`);return t})}getStoryIndex(r){let t=Object.keys(this.csfExports),p=this.projectAnnotations.parameters?.options?.storySort,g=Object.entries(this.entries).map(([n,{type:y,importPath:a,...d}])=>{let s=this.csfExports[a],i=r.processCSFFileWithCache(s,a,s.default.title),f;return y===\"story\"?f=r.storyFromCSFFile({storyId:n,csfFile:i}):f={...d,story:d.name,kind:d.title,componentId:x(d.componentId||d.title),parameters:{fileName:a}},[n,f,i.meta.parameters,this.projectAnnotations.parameters]}),c;try{c=C(g,p,t)}catch(n){throw typeof p==\"function\"?new Error(G`\n          Error sorting stories with sort parameter ${p}:\n\n          > ${n.message}\n          \n          Are you using a V7-style sort function in V6 compatibility mode?\n          \n          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n        `):n}let e=c.reduce((n,y)=>(n[y.id]=this.entries[y.id],n),{});return{v:4,entries:e}}clearFilenameExports(r){!this.csfExports[r]||(Object.entries(this.entries).forEach(([t,{importPath:p}])=>{p===r&&delete this.entries[t]}),this.csfExports[r]={})}addStoriesFromExports(r,t){if(r.match(/\\.mdx$/)&&!r.match(/\\.stories\\.mdx$/)||this.csfExports[r]===t)return;this.clearFilenameExports(r);let{default:p,__namedExportsOrder:m,...g}=t,{id:c,title:e}=p||{},n=(k.STORIES||[]).map(s=>({...s,importPathMatcher:new RegExp(s.importPathMatcher)}));if(e=_(r,n,e),!e){D.info(`Unexpected default export without title in '${r}': ${JSON.stringify(t.default)}`);return}this.csfExports[r]={...t,default:{...p,title:e}};let y=g;Array.isArray(m)&&(y={},m.forEach(s=>{let i=g[s];i&&(y[s]=i)}));let a=Object.entries(y).filter(([s])=>v(s,p));a.forEach(([s,i])=>{let f=M(s),u=i.parameters?.__id||x(c||e,f),w=typeof i!=\"function\"&&i.name||i.storyName||i.story?.name||f;i.parameters?.docsOnly||(this.entries[u]={type:\"story\",id:u,name:w,title:e,importPath:r,componentId:c})});let d=k.DOCS_OPTIONS||{};if(d.enabled&&a.length&&(r.match(/\\.mdx$/)||d.docsPage)){let s=d.defaultName,i=x(c||e,s);this.entries[i]={type:\"docs\",standalone:!1,id:i,title:e,name:s,importPath:r,storiesImports:[],componentId:c}}}};var l,K={addDecorator:\"Instead, use `export const decorators = [];` in your `preview.js`.\",addParameters:\"Instead, use `export const parameters = {};` in your `preview.js`.\",addLoader:\"Instead, use `export const loaders = [];` in your `preview.js`.\",addArgs:\"\",addArgTypes:\"\",addArgsEnhancer:\"\",addArgTypesEnhancer:\"\",addStepRunner:\"\",getGlobalRender:\"\",setGlobalRender:\"\"},h=o=>{if(N.FEATURES?.storyStoreV7)throw new Error(L`You cannot use \\`${o}\\` with the new Story Store.\n\n      ${K[o]}`);if(!l)throw new Error(`Singleton client API not yet initialized, cannot call \\`${o}\\`.`)},Q=o=>{h(\"addDecorator\"),l.addDecorator(o)},U=o=>{h(\"addParameters\"),l.addParameters(o)},B=o=>{h(\"addLoader\"),l.addLoader(o)},H=o=>{h(\"addArgs\"),l.addArgs(o)},J=o=>{h(\"addArgTypes\"),l.addArgTypes(o)},W=o=>{h(\"addArgsEnhancer\"),l.addArgsEnhancer(o)},q=o=>{h(\"addArgTypesEnhancer\"),l.addArgTypesEnhancer(o)},X=o=>{h(\"addStepRunner\"),l.addStepRunner(o)};var Z=o=>{h(\"setGlobalRender\"),l.facade.projectAnnotations.render=o},rr=new Set([\"string\",\"number\",\"boolean\",\"symbol\"]),E=class{constructor({storyStore:r}={}){this.lastFileName=0;this.addDecorator=r=>{this.facade.projectAnnotations.decorators.push(r)};this.addParameters=({globals:r,globalTypes:t,...p})=>{this.facade.projectAnnotations.parameters=T(this.facade.projectAnnotations.parameters,p),r&&(this.facade.projectAnnotations.globals={...this.facade.projectAnnotations.globals,...r}),t&&(this.facade.projectAnnotations.globalTypes={...this.facade.projectAnnotations.globalTypes,...I(t)})};this.addStepRunner=r=>{this.facade.projectAnnotations.runStep=Y([this.facade.projectAnnotations.runStep,r].filter(Boolean))};this.addLoader=r=>{this.facade.projectAnnotations.loaders.push(r)};this.addArgs=r=>{this.facade.projectAnnotations.args={...this.facade.projectAnnotations.args,...r}};this.addArgTypes=r=>{this.facade.projectAnnotations.argTypes={...this.facade.projectAnnotations.argTypes,...I(r)}};this.addArgsEnhancer=r=>{this.facade.projectAnnotations.argsEnhancers.push(r)};this.addArgTypesEnhancer=r=>{this.facade.projectAnnotations.argTypesEnhancers.push(r)};this._addedExports={};this.storiesOf=(r,t)=>{if(!r&&typeof r!=\"string\")throw new Error(\"Invalid or missing kind provided for stories, should be a string\");if(t||b.warn(`Missing 'module' parameter for story with a kind of '${r}'. It will break your HMR`),t){let a=Object.getPrototypeOf(t);a.exports&&a.exports.default&&b.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${a.i}`)}let p=t&&t.id?`${t.id}`:(this.lastFileName++).toString(),m=p,g=1;for(;this._addedExports[m];)g+=1,m=`${p}-${g}`;t&&t.hot&&t.hot.accept&&(t.hot.accept(),t.hot.dispose(()=>{this.facade.clearFilenameExports(m),delete this._addedExports[m],setTimeout(()=>{this._loadAddedExports(),this.onImportFnChanged?.({importFn:this.importFn.bind(this)})},0)}));let c=!1,e={kind:r.toString(),add:()=>e,addDecorator:()=>e,addLoader:()=>e,addParameters:()=>e};Object.keys(this.addons).forEach(a=>{let d=this.addons[a];e[a]=(...s)=>(d.apply(e,s),e)});let n={id:V(r),title:r,decorators:[],loaders:[],parameters:{}};this._addedExports[m]={default:n};let y=0;return e.add=(a,d,s={})=>{if(c=!0,typeof a!=\"string\")throw new Error(`Invalid or missing storyName provided for a \"${r}\" story.`);if(!d||Array.isArray(d)||rr.has(typeof d))throw new Error(`Cannot load story \"${a}\" in \"${r}\" due to invalid format. Storybook expected a function/object but received ${typeof d} instead.`);let{decorators:i,loaders:f,component:u,args:w,argTypes:P,...j}=s,R=s.__id||z(r,a),O=this._addedExports[m];return O[`story${y}`]={name:a,parameters:{fileName:m,__id:R,...j},decorators:i,loaders:f,args:w,argTypes:P,component:u,render:d},y+=1,e},e.addDecorator=a=>{if(c)throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);return n.decorators.push(a),e},e.addLoader=a=>{if(c)throw new Error(\"You cannot add a loader after the first story for a kind.\");return n.loaders.push(a),e},e.addParameters=({component:a,args:d,argTypes:s,...i})=>{if(c)throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);return n.parameters=T(n.parameters,i),a&&(n.component=a),d&&(n.args={...n.args,...d}),s&&(n.argTypes={...n.argTypes,...s}),e},e};this.raw=()=>this.storyStore.raw();this.facade=new A,this.addons={},this.storyStore=r,l=this}importFn(r){return this.facade.importFn(r)}getStoryIndex(){if(!this.storyStore)throw new Error(\"Cannot get story index before setting storyStore\");return this.facade.getStoryIndex(this.storyStore)}_loadAddedExports(){Object.entries(this._addedExports).forEach(([r,t])=>this.facade.addStoriesFromExports(r,t))}get _storyStore(){return this.storyStore}};import tr from\"global\";import{parse as er}from\"qs\";var{document:S}=tr,or=()=>S&&S.location&&S.location.search?er(S.location.search,{ignoreQueryPrefix:!0}):{},br=o=>or()[o];export*from\"@storybook/store\";export{E as ClientApi,J as addArgTypes,q as addArgTypesEnhancer,H as addArgs,W as addArgsEnhancer,Q as addDecorator,B as addLoader,U as addParameters,X as addStepRunner,br as getQueryParam,or as getQueryParams,Z as setGlobalRender};\n","import { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { CONFIG_ERROR, FORCE_REMOUNT, FORCE_RE_RENDER, GLOBALS_UPDATED, RESET_STORY_ARGS, SET_GLOBALS, STORY_ARGS_UPDATED, STORY_INDEX_INVALIDATED, UPDATE_GLOBALS, UPDATE_STORY_ARGS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { StoryRender } from './render/StoryRender';\nconst {\n  fetch\n} = global;\nconst STORY_INDEX_PATH = './index.json';\nexport class Preview {\n  constructor(channel = addons.getChannel()) {\n    this.channel = channel;\n    this.serverChannel = void 0;\n    this.storyStore = void 0;\n    this.getStoryIndex = void 0;\n    this.importFn = void 0;\n    this.renderToDOM = void 0;\n    this.storyRenders = [];\n    this.previewEntryError = void 0;\n\n    if (global.FEATURES?.storyStoreV7 && addons.hasServerChannel()) {\n      this.serverChannel = addons.getServerChannel();\n    }\n\n    this.storyStore = new StoryStore();\n  } // INITIALIZATION\n  // NOTE: the reason that the preview and store's initialization code is written in a promise\n  // style and not `async-await`, and the use of `SynchronousPromise`s is in order to allow\n  // storyshots to immediately call `raw()` on the store without waiting for a later tick.\n  // (Even simple things like `Promise.resolve()` and `await` involve the callback happening\n  // in the next promise \"tick\").\n  // See the comment in `storyshots-core/src/api/index.ts` for more detail.\n\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    // We save these two on initialization in case `getProjectAnnotations` errors,\n    // in which case we may need them later when we recover.\n    this.getStoryIndex = getStoryIndex;\n    this.importFn = importFn;\n    this.setupListeners();\n    return this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then(projectAnnotations => this.initializeWithProjectAnnotations(projectAnnotations));\n  }\n\n  setupListeners() {\n    this.serverChannel?.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));\n    this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this));\n    this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this));\n    this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    return SynchronousPromise.resolve().then(getProjectAnnotations).then(projectAnnotations => {\n      this.renderToDOM = projectAnnotations.renderToDOM;\n\n      if (!this.renderToDOM) {\n        throw new Error(dedent`\n            Expected your framework's preset to export a \\`renderToDOM\\` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field\n          `);\n      }\n\n      return projectAnnotations;\n    }).catch(err => {\n      // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n      this.renderPreviewEntryError('Error reading preview.js:', err);\n      throw err;\n    });\n  } // If initialization gets as far as project annotations, this function runs.\n\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.setInitialGlobals();\n    let storyIndexPromise;\n\n    if (global.FEATURES?.storyStoreV7) {\n      storyIndexPromise = this.getStoryIndexFromServer();\n    } else {\n      if (!this.getStoryIndex) {\n        throw new Error('No `getStoryIndex` passed defined in v6 mode');\n      }\n\n      storyIndexPromise = SynchronousPromise.resolve().then(this.getStoryIndex);\n    }\n\n    return storyIndexPromise.then(storyIndex => this.initializeWithStoryIndex(storyIndex)).catch(err => {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    });\n  }\n\n  async setInitialGlobals() {\n    this.emitGlobals();\n  }\n\n  emitGlobals() {\n    if (!this.storyStore.globals || !this.storyStore.projectAnnotations) throw new Error(`Cannot emit before initialization`);\n    this.channel.emit(SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n  }\n\n  async getStoryIndexFromServer() {\n    const result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200) return result.json();\n    throw new Error(await result.text());\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    if (!this.importFn) throw new Error(`Cannot call initializeWithStoryIndex before initialization`);\n    return this.storyStore.initialize({\n      storyIndex,\n      importFn: this.importFn,\n      cache: !global.FEATURES?.storyStoreV7\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError;\n    const projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!this.storyStore.projectAnnotations) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n\n    await this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.emitGlobals();\n  }\n\n  async onStoryIndexChanged() {\n    delete this.previewEntryError;\n\n    if (!this.storyStore.projectAnnotations) {\n      // We haven't successfully set project annotations yet,\n      // we need to do that before we can do anything else.\n      return;\n    }\n\n    try {\n      const storyIndex = await this.getStoryIndexFromServer(); // This is the first time the story index worked, let's load it into the store\n\n      if (!this.storyStore.storyIndex) {\n        await this.initializeWithStoryIndex(storyIndex);\n      } // Update the store with the new stories.\n\n\n      await this.onStoriesChanged({\n        storyIndex\n      });\n    } catch (err) {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    }\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    if (!this.storyStore.globals) throw new Error(`Cannot call onUpdateGlobals before initialization`);\n    this.storyStore.globals.update(globals);\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n    this.channel.emit(GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.rerender()));\n    this.channel.emit(STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating a rendered's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.storyRenders`\n    const render = this.storyRenders.find(r => r.id === storyId);\n    const story = render?.story || (await this.storyStore.loadStory({\n      storyId\n    }));\n    const argNamesToReset = argNames || [...new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])];\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = story.initialArgs[argName];\n      return acc;\n    }, {});\n    await this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  } // ForceReRender does not include a story id, so we simply must\n  // re-render all stories in case they are relevant\n\n\n  async onForceReRender() {\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n  }\n\n  async onForceRemount({\n    storyId\n  }) {\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.remount()));\n  } // Used by docs' modernInlineRender to render a story to a given element\n  // Note this short-circuits the `prepare()` phase of the StoryRender,\n  // main to be consistent with the previous behaviour. In the future,\n  // we will change it to go ahead and load the story, which will end up being\n  // \"instant\", although async.\n\n\n  renderStoryToElement(story, element) {\n    if (!this.renderToDOM) throw new Error(`Cannot call renderStoryToElement before initialization`);\n    const render = new StoryRender(this.channel, this.storyStore, this.renderToDOM, this.inlineStoryCallbacks(story.id), story.id, 'docs', story);\n    render.renderToElement(element);\n    this.storyRenders.push(render);\n    return async () => {\n      await this.teardownRender(render);\n    };\n  }\n\n  async teardownRender(render, {\n    viewModeChanged\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n\n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err;\n    logger.error(reason);\n    logger.error(err);\n    this.channel.emit(CONFIG_ERROR, err);\n  }\n\n}","import qs from 'qs';\nimport { dedent } from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport { dedent } from 'ts-dedent';\nimport qs from 'qs';\nconst {\n  document\n} = global;\nconst PREPARING_DELAY = 100;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nvar Mode;\n\n(function (Mode) {\n  Mode[\"MAIN\"] = \"MAIN\";\n  Mode[\"NOPREVIEW\"] = \"NOPREVIEW\";\n  Mode[\"PREPARING_STORY\"] = \"PREPARING_STORY\";\n  Mode[\"PREPARING_DOCS\"] = \"PREPARING_DOCS\";\n  Mode[\"ERROR\"] = \"ERROR\";\n})(Mode || (Mode = {}));\n\nconst classes = {\n  PREPARING_STORY: 'sb-show-preparing-story',\n  PREPARING_DOCS: 'sb-show-preparing-docs',\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n    this.testing = false;\n    this.preparingTimeout = void 0;\n    // Special code for testing situations\n    const {\n      __SPECIAL_TEST_PARAMETER__\n    } = qs.parse(document.location.search, {\n      ignoreQueryPrefix: true\n    });\n\n    switch (__SPECIAL_TEST_PARAMETER__) {\n      case 'preparing-story':\n        {\n          this.showPreparingStory();\n          this.testing = true;\n          break;\n        }\n\n      case 'preparing-docs':\n        {\n          this.showPreparingDocs();\n          this.testing = true;\n          break;\n        }\n\n      default: // pass;\n\n    }\n  } // Get ready to render a story, returning the element to render to\n\n\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('storybook-root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('storybook-docs');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showMode(mode) {\n    clearTimeout(this.preparingTimeout);\n    Object.keys(Mode).forEach(otherMode => {\n      if (otherMode === mode) {\n        document.body.classList.add(classes[otherMode]);\n      } else {\n        document.body.classList.remove(classes[otherMode]);\n      }\n    });\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    let header = message;\n    let detail = stack;\n    const parts = message.split('\\n');\n\n    if (parts.length > 1) {\n      [header] = parts;\n      detail = parts.slice(1).join('\\n');\n    }\n\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(header);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(detail);\n    this.showMode(Mode.ERROR);\n  }\n\n  showNoPreview() {\n    if (this.testing) return;\n    this.showMode(Mode.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    this.storyRoot()?.setAttribute('hidden', 'true');\n    this.docsRoot()?.setAttribute('hidden', 'true');\n  }\n\n  showPreparingStory({\n    immediate = false\n  } = {}) {\n    clearTimeout(this.preparingTimeout);\n\n    if (immediate) {\n      this.showMode(Mode.PREPARING_STORY);\n    } else {\n      this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_STORY), PREPARING_DELAY);\n    }\n  }\n\n  showPreparingDocs() {\n    clearTimeout(this.preparingTimeout);\n    this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_DOCS), PREPARING_DELAY);\n  }\n\n  showMain() {\n    this.showMode(Mode.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n  showStoryDuringRender() {\n    // When 'showStory' is called (at the start of rendering) we get rid of our display:none\n    // from all children of the root (but keep the preparing spinner visible). This may mean\n    // that very weird and high z-index stories are briefly visible.\n    // See https://github.com/storybookjs/storybook/issues/16847 and\n    //   http://localhost:9011/?path=/story/core-rendering--auto-focus (official SB)\n    document.body.classList.add(classes.MAIN);\n  }\n\n}","import { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { CURRENT_STORY_WAS_SET, PRELOAD_ENTRIES, PREVIEW_KEYDOWN, SET_CURRENT_STORY, SET_INDEX, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_QUERY_PARAMS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { Preview } from './Preview';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nimport { PREPARE_ABORTED } from './render/Render';\nimport { StoryRender } from './render/StoryRender';\nimport { TemplateDocsRender } from './render/TemplateDocsRender';\nimport { StandaloneDocsRender } from './render/StandaloneDocsRender';\nconst {\n  window: globalWindow\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nfunction isStoryRender(r) {\n  return r.type === 'story';\n}\n\nexport class PreviewWeb extends Preview {\n  constructor() {\n    super();\n    this.urlStore = void 0;\n    this.view = void 0;\n    this.previewEntryError = void 0;\n    this.currentSelection = void 0;\n    this.currentRender = void 0;\n    this.view = new WebView();\n    this.urlStore = new UrlStore();\n  }\n\n  setupListeners() {\n    super.setupListeners();\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));\n  }\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    return super.initializeWithProjectAnnotations(projectAnnotations).then(() => this.setInitialGlobals());\n  }\n\n  async setInitialGlobals() {\n    if (!this.storyStore.globals) throw new Error(`Cannot call setInitialGlobals before initialization`);\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.emitGlobals();\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    return super.initializeWithStoryIndex(storyIndex).then(() => {\n      if (!global.FEATURES?.storyStoreV7) {\n        this.channel.emit(SET_INDEX, this.storyStore.getSetIndexPayload());\n      }\n\n      return this.selectSpecifiedStory();\n    });\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.storyStore.storyIndex) throw new Error(`Cannot call selectSpecifiedStory before initialization`);\n\n    if (!this.urlStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);\n\n    if (!entry) {\n      if (storySpecifier === '*') {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find any stories in your Storybook.\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      } else {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find story matching '${storySpecifier}'.\n            - Are you sure a story with that id exists?\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      }\n\n      return;\n    }\n\n    const {\n      id: storyId,\n      type: viewMode\n    } = entry;\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    await super.onGetProjectAnnotationsChanged({\n      getProjectAnnotations\n    });\n\n    if (this.urlStore.selection) {\n      this.renderSelection();\n    }\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await super.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (!global.FEATURES?.storyStoreV7) {\n      this.channel.emit(SET_INDEX, await this.storyStore.getSetIndexPayload());\n    }\n\n    if (this.urlStore.selection) {\n      await this.renderSelection();\n    } else {\n      // Our selection has never applied before, but maybe it does now, let's try!\n      await this.selectSpecifiedStory();\n    }\n  }\n\n  onKeydown(event) {\n    if (!this.currentRender?.disableKeyListeners && !focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  async onSetCurrentStory(selection) {\n    await this.storyStore.initializationPromise;\n    this.urlStore.setSelection(Object.assign({\n      viewMode: 'story'\n    }, selection));\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateQueryParams(queryParams) {\n    this.urlStore.setQueryParams(queryParams);\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    super.onUpdateGlobals({\n      globals\n    });\n\n    if (this.currentRender instanceof StandaloneDocsRender || this.currentRender instanceof TemplateDocsRender) {\n      await this.currentRender.rerender?.();\n    }\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    super.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  }\n\n  async onPreloadStories({\n    ids\n  }) {\n    /**\n     * It's possible that we're trying to preload a story in a ref we haven't loaded the iframe for yet.\n     * Because of the way the targeting works, if we can't find the targeted iframe,\n     * we'll use the currently active iframe which can cause the event to be targeted\n     * to the wrong iframe, causing an error if the storyId does not exists there.\n     */\n    await Promise.allSettled(ids.map(id => this.storyStore.loadEntry(id)));\n  } // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    const {\n      renderToDOM\n    } = this;\n    if (!renderToDOM) throw new Error('Cannot call renderSelection before initialization');\n    const {\n      selection\n    } = this.urlStore;\n    if (!selection) throw new Error('Cannot call renderSelection as no selection was made');\n    const {\n      storyId\n    } = selection;\n    let entry;\n\n    try {\n      entry = await this.storyStore.storyIdToEntry(storyId);\n    } catch (err) {\n      if (this.currentRender) await this.teardownRender(this.currentRender);\n      this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n\n    const storyIdChanged = this.currentSelection?.storyId !== storyId;\n    const viewModeChanged = this.currentRender?.type !== entry.type; // Show a spinner while we load the next story\n\n    if (entry.type === 'story') {\n      this.view.showPreparingStory({\n        immediate: viewModeChanged\n      });\n    } else {\n      this.view.showPreparingDocs();\n    } // If the last render is still preparing, let's drop it right now. Either\n    //   (a) it is a different story, which means we would drop it later, OR\n    //   (b) it is the *same* story, in which case we will resolve our own .prepare() at the\n    //       same moment anyway, and we should just \"take over\" the rendering.\n    // (We can't tell which it is yet, because it is possible that an HMR is going on and\n    //  even though the storyId is the same, the story itself is not).\n\n\n    if (this.currentRender?.isPreparing()) {\n      await this.teardownRender(this.currentRender);\n    }\n\n    let render;\n\n    if (entry.type === 'story') {\n      render = new StoryRender(this.channel, this.storyStore, (...args) => {\n        // At the start of renderToDOM we make the story visible (see note in WebView)\n        this.view.showStoryDuringRender();\n        return renderToDOM(...args);\n      }, this.mainStoryCallbacks(storyId), storyId, 'story');\n    } else if (entry.standalone) {\n      render = new StandaloneDocsRender(this.channel, this.storyStore, entry);\n    } else {\n      render = new TemplateDocsRender(this.channel, this.storyStore, entry);\n    } // We need to store this right away, so if the story changes during\n    // the async `.prepare()` below, we can (potentially) cancel it\n\n\n    const lastSelection = this.currentSelection;\n    this.currentSelection = selection;\n    const lastRender = this.currentRender;\n    this.currentRender = render;\n\n    try {\n      await render.prepare();\n    } catch (err) {\n      if (err !== PREPARE_ABORTED) {\n        // We are about to render an error so make sure the previous story is\n        // no longer rendered.\n        if (lastRender) await this.teardownRender(lastRender);\n        this.renderStoryLoadingException(storyId, err);\n      }\n\n      return;\n    }\n\n    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);\n\n    if (persistedArgs && isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.currentRender = lastRender;\n      this.channel.emit(STORY_UNCHANGED, storyId);\n      this.view.showMain();\n      return;\n    } // Wait for the previous render to leave the page. NOTE: this will wait to ensure anything async\n    // is properly aborted, which (in some cases) can lead to the whole screen being refreshed.\n\n\n    if (lastRender) await this.teardownRender(lastRender, {\n      viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (lastSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(STORY_CHANGED, storyId);\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      const {\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      } = this.storyStore.getStoryContext(render.story);\n\n      if (global.FEATURES?.storyStoreV7) {\n        this.channel.emit(STORY_PREPARED, {\n          id: storyId,\n          parameters,\n          initialArgs,\n          argTypes,\n          args\n        });\n      } // For v6 mode / compatibility\n      // If the implementation changed, or args were persisted, the args may have changed,\n      // and the STORY_PREPARED event above may not be respected.\n\n\n      if (implementationChanged || persistedArgs) {\n        this.channel.emit(STORY_ARGS_UPDATED, {\n          storyId,\n          args\n        });\n      }\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyRenders.push(render);\n      this.currentRender.renderToElement(this.view.prepareForStory(render.story));\n    } else {\n      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));\n    }\n  }\n\n  async teardownRender(render, {\n    viewModeChanged = false\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n\n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  mainStoryCallbacks(storyId) {\n    return {\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(storyId, err),\n      showException: err => this.renderException(storyId, err)\n    };\n  }\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    super.renderPreviewEntryError(reason, err);\n    this.view.showErrorDisplay(err);\n  }\n\n  renderMissingStory() {\n    this.view.showNoPreview();\n    this.channel.emit(STORY_MISSING);\n  }\n\n  renderStoryLoadingException(storySpecifier, err) {\n    // logger.error(`Unable to load story '${storySpecifier}':`);\n    logger.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(storyId, error) {\n    const {\n      name = 'Error',\n      message = String(error),\n      stack\n    } = error;\n    this.channel.emit(STORY_THREW_EXCEPTION, {\n      name,\n      message,\n      stack\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.\n    //\n    // FIXME: Should be '=== IGNORED_EXCEPTION', but currently the object\n    // is coming from two different bundles (index.js vs index.mjs)\n    //\n    // https://github.com/storybookjs/storybook/issues/19321\n\n    if (!error.message?.startsWith('ignoredException')) {\n      this.view.showErrorDisplay(error);\n      logger.error(`Error rendering story '${storyId}':`);\n      logger.error(error);\n    }\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError(storyId, {\n    title,\n    description\n  }) {\n    logger.error(`Error rendering story ${title}: ${description}`);\n    this.channel.emit(STORY_ERRORED, {\n      title,\n      description\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import xr from\"memoizerific\";import ke from\"lodash/mapValues\";import kr from\"lodash/pick\";import{SynchronousPromise as nr}from\"synchronous-promise\";import{dedent as Gr}from\"ts-dedent\";import Mr from\"memoizerific\";var _r=Mr(1)(e=>Object.values(e).reduce((r,t)=>(r[t.importPath]=r[t.importPath]||t,r),{})),z=class{constructor({entries:r}={v:4,entries:{}}){this.entries=r}entryFromSpecifier(r){let t=Object.values(this.entries);if(r===\"*\")return t[0];if(typeof r==\"string\")return this.entries[r]?this.entries[r]:t.find(s=>s.id.startsWith(r));let{name:o,title:n}=r;return t.find(s=>s.name===o&&s.title===n)}storyIdToEntry(r){let t=this.entries[r];if(!t)throw new Error(Gr`Couldn't find story matching '${r}' after HMR.\n      - Did you remove it from your CSF file?\n      - Are you sure a story with that id exists?\n      - Please check your entries field of your main.js config.\n      - Also check the browser console and terminal for error messages.`);return t}importPathToEntry(r){return _r(this.entries)[r]}};import{dequal as vr}from\"dequal\";import{once as J}from\"@storybook/client-logger\";import N from\"lodash/isPlainObject\";import{dedent as cr}from\"ts-dedent\";var x=Symbol(\"incompatible\"),Y=(e,r)=>{let t=r.type;if(e==null||!t||r.mapping)return e;switch(t.name){case\"string\":return String(e);case\"enum\":return e;case\"number\":return Number(e);case\"boolean\":return e===\"true\";case\"array\":return!t.value||!Array.isArray(e)?x:e.reduce((o,n,s)=>{let i=Y(n,{type:t.value});return i!==x&&(o[s]=i),o},new Array(e.length));case\"object\":return typeof e==\"string\"||typeof e==\"number\"?e:!t.value||typeof e!=\"object\"?x:Object.entries(e).reduce((o,[n,s])=>{let i=Y(s,{type:t.value[n]});return i===x?o:Object.assign(o,{[n]:i})},{});default:return x}},pr=(e,r)=>Object.entries(e).reduce((t,[o,n])=>{if(!r[o])return t;let s=Y(n,r[o]);return s===x?t:Object.assign(t,{[o]:s})},{}),R=(e,r)=>Array.isArray(e)&&Array.isArray(r)?r.reduce((t,o,n)=>(t[n]=R(e[n],r[n]),t),[...e]).filter(t=>t!==void 0):!N(e)||!N(r)?r:Object.keys({...e,...r}).reduce((t,o)=>{if(o in r){let n=R(e[o],r[o]);n!==void 0&&(t[o]=n)}else t[o]=e[o];return t},{}),dr=(e,r)=>Object.entries(r).reduce((t,[o,{options:n}])=>{function s(){return o in e&&(t[o]=e[o]),t}if(!n)return s();if(!Array.isArray(n))return J.error(cr`\n        Invalid argType: '${o}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `),s();if(n.some(y=>y&&[\"object\",\"function\"].includes(typeof y)))return J.error(cr`\n        Invalid argType: '${o}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `),s();let i=Array.isArray(e[o]),a=i&&e[o].findIndex(y=>!n.includes(y)),m=i&&a===-1;if(e[o]===void 0||n.includes(e[o])||m)return s();let l=i?`${o}[${a}]`:o,d=n.map(y=>typeof y==\"string\"?`'${y}'`:String(y)).join(\", \");return J.warn(`Received illegal value for '${l}'. Supported options: ${d}`),t},{}),b=Symbol(\"Deeply equal\"),k=(e,r)=>{if(typeof e!=typeof r)return r;if(vr(e,r))return b;if(Array.isArray(e)&&Array.isArray(r)){let t=r.reduce((o,n,s)=>{let i=k(e[s],n);return i!==b&&(o[s]=i),o},new Array(r.length));return r.length>=e.length?t:t.concat(new Array(e.length-r.length).fill(void 0))}return N(e)&&N(r)?Object.keys({...e,...r}).reduce((t,o)=>{let n=k(e?.[o],r?.[o]);return n===b?t:Object.assign(t,{[o]:n})},{}):r},B=\"\";function q({args:e,argTypes:r}){let t={};return Object.entries(e).forEach(([o,n])=>{let{target:s=B}=r[o]||{};t[s]=t[s]||{},t[s][o]=n}),t}function Le(e){return q(e)[B]}function $r(e){return Object.keys(e).forEach(r=>e[r]===void 0&&delete e[r]),e}var D=class{constructor(){this.initialArgsByStoryId={};this.argsByStoryId={}}get(r){if(!(r in this.argsByStoryId))throw new Error(`No args known for ${r} -- has it been rendered yet?`);return this.argsByStoryId[r]}setInitial(r){if(!this.initialArgsByStoryId[r.id])this.initialArgsByStoryId[r.id]=r.initialArgs,this.argsByStoryId[r.id]=r.initialArgs;else if(this.initialArgsByStoryId[r.id]!==r.initialArgs){let t=k(this.initialArgsByStoryId[r.id],this.argsByStoryId[r.id]);this.initialArgsByStoryId[r.id]=r.initialArgs,this.argsByStoryId[r.id]=r.initialArgs,t!==b&&this.updateFromDelta(r,t)}}updateFromDelta(r,t){let o=dr(t,r.argTypes);this.argsByStoryId[r.id]=R(this.argsByStoryId[r.id],o)}updateFromPersisted(r,t){let o=pr(t,r.argTypes);return this.updateFromDelta(r,o)}update(r,t){if(!(r in this.argsByStoryId))throw new Error(`No args known for ${r} -- has it been rendered yet?`);this.argsByStoryId[r]=$r({...this.argsByStoryId[r],...t})}};import Vr from\"util-deprecate\";import{dedent as Lr}from\"ts-dedent\";var C=(e={})=>Object.entries(e).reduce((r,[t,{defaultValue:o}])=>(typeof o<\"u\"&&(r[t]=o),r),{});var Wr=Vr(()=>{},Lr`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `),G=class{constructor({globals:r={},globalTypes:t={}}){this.set({globals:r,globalTypes:t})}set({globals:r={},globalTypes:t={}}){let o=this.initialGlobals&&k(this.initialGlobals,this.globals);this.allowedGlobalNames=new Set([...Object.keys(r),...Object.keys(t)]);let n=C(t);this.initialGlobals={...n,...r},this.globals=this.initialGlobals,o&&o!==b&&this.updateFromPersisted(o)}filterAllowedGlobals(r){return Object.entries(r).reduce((t,[o,n])=>(this.allowedGlobalNames.has(o)&&(t[o]=n),t),{})}updateFromPersisted(r){let t=this.filterAllowedGlobals(r);this.globals={...this.globals,...t}}get(){return this.globals}update(r){Object.keys(r).forEach(t=>{this.allowedGlobalNames.has(t)||Wr()}),this.globals={...this.globals,...r}}};import Hr from\"lodash/mapValues\";var Ur=e=>typeof e==\"string\"?{name:e}:e,Jr=e=>typeof e==\"string\"?{type:e}:e,Yr=(e,r)=>{let{type:t,control:o,...n}=e,s={name:r,...n};return t&&(s.type=Ur(t)),o?s.control=Jr(o):o===!1&&(s.control={disable:!0}),s},w=e=>Hr(e,Yr);import{storyNameFromExport as qr,toId as Kr}from\"@storybook/csf\";import{dedent as Qr}from\"ts-dedent\";import{logger as Zr}from\"@storybook/client-logger\";import Xr from\"util-deprecate\";var re=Qr`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`,ee=Xr(()=>{},re);function M(e,r,t){let o=r,n=typeof r==\"function\"?r:null,{story:s}=o;s&&(Zr.debug(\"deprecated story\",s),ee());let i=qr(e),a=typeof o!=\"function\"&&o.name||o.storyName||s?.name||i,m=[...o.decorators||[],...s?.decorators||[]],l={...s?.parameters,...o.parameters},d={...s?.args,...o.args},y={...s?.argTypes,...o.argTypes},u=[...o.loaders||[],...s?.loaders||[]],{render:g,play:h}=o,U=l.__id||Kr(t.id,i);return{moduleExport:r,id:U,name:a,decorators:m,parameters:l,args:d,argTypes:w(y),loaders:u,...g&&{render:g},...n&&{userStoryFn:n},...h&&{play:h}}}import{isExportStory as oe}from\"@storybook/csf\";import{logger as ur}from\"@storybook/client-logger\";import{sanitize as te}from\"@storybook/csf\";function _(e,r=e.title,t){let{id:o,argTypes:n}=e;return{id:te(o||r),...e,title:r,...n&&{argTypes:w(n)},parameters:{fileName:t,...e.parameters}}}var ne=e=>{let{globals:r,globalTypes:t}=e;(r||t)&&ur.error(\"Global args/argTypes can only be set globally\",JSON.stringify({globals:r,globalTypes:t}))},se=e=>{let{options:r}=e;r?.storySort&&ur.error(\"The storySort option parameter can only be set globally\")},fr=e=>{!e||(ne(e),se(e))};function gr(e,r,t){let{default:o,__namedExportsOrder:n,...s}=e,i=_(o,t,r);fr(i.parameters);let a={meta:i,stories:{}};return Object.keys(s).forEach(m=>{if(oe(m,i)){let l=M(m,s[m],i);fr(l.parameters),a.stories[l.id]=l}}),a}import{dedent as fe}from\"ts-dedent\";import ue from\"util-deprecate\";import hr from\"global\";import{includeConditionalArg as ge}from\"@storybook/csf\";import K from\"lodash/isPlainObject\";var F=(...e)=>{let r={},t=e.filter(Boolean),o=t.reduce((n,s)=>(Object.entries(s).forEach(([i,a])=>{let m=n[i];Array.isArray(a)||typeof m>\"u\"?n[i]=a:K(a)&&K(m)?r[i]=!0:typeof a<\"u\"&&(n[i]=a)}),n),{});return Object.keys(r).forEach(n=>{let s=t.filter(Boolean).map(i=>i[n]).filter(i=>typeof i<\"u\");s.every(i=>K(i))?o[n]=F(...s):o[n]=s[s.length-1]}),o};import{SHARED_STATE_CHANGED as Q,SHARED_STATE_SET as Z}from\"@storybook/core-events\";import{addons as ie,HooksContext as v,applyHooks as Sr,useMemo as ae,useCallback as ht,useRef as Tt,useState as le,useReducer as At,useEffect as me,useChannel as ye,useStoryContext as bt,useParameter as wt,useArgs as xt,useGlobals as kt}from\"@storybook/addons\";function ce(e,r){let t=ie.getChannel(),[o]=t.last(`${Q}-manager-${e}`)||t.last(`${Z}-manager-${e}`)||[],[n,s]=le(o||r),i=ae(()=>({[`${Q}-manager-${e}`]:m=>s(m),[`${Z}-manager-${e}`]:m=>s(m)}),[e]),a=ye(i,[e]);return me(()=>{r!==void 0&&!o&&a(`${Z}-client-${e}`,r)},[e]),[n,m=>{s(m),a(`${Q}-client-${e}`,m)}]}function Ct(e,r){return ce(e,r)}function pe(e,r,t){let o=t(e);return n=>r(o,n)}function de({componentId:e,title:r,kind:t,id:o,name:n,story:s,parameters:i,initialArgs:a,argTypes:m,...l}={}){return l}function Fr(e,r){let t={},o=s=>i=>{if(!t.value)throw new Error(\"Decorated function called without init\");return t.value={...t.value,...de(i)},s(t.value)},n=r.reduce((s,i)=>pe(s,i,o),e);return s=>(t.value=s,n(s))}var Se=ue(()=>{},fe`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`);function $(e,r,t){let{moduleExport:o,id:n,name:s}=e,{title:i}=r,a=F(t.parameters,r.parameters,e.parameters),m=[...e.decorators||[],...r.decorators||[],...t.decorators||[]],{applyDecorators:l=Fr,argTypesEnhancers:d=[],argsEnhancers:y=[],runStep:u}=t,g=[...t.loaders||[],...r.loaders||[],...e.loaders||[]],h=e.userStoryFn||e.render||r.render||t.render;if(!h)throw new Error(`No render function available for storyId '${n}'`);let U=F(t.argTypes,r.argTypes,e.argTypes),{passArgsFirst:jr=!0}=a;a.__isArgsStory=jr&&h.length>0;let ar={...t.args,...r.args,...e.args},S={componentId:r.id,title:i,kind:i,id:n,name:s,story:s,component:r.component,subcomponents:r.subcomponents,parameters:a,initialArgs:ar,argTypes:U};S.argTypes=d.reduce((p,f)=>f({...S,argTypes:p}),S.argTypes);let lr=C(S.argTypes);Object.keys(lr).length>0&&Se();let zr={...lr,...ar};S.initialArgs=y.reduce((p,f)=>({...p,...f({...S,initialArgs:p})}),zr),hr.FEATURES?.breakingChangesV7||(S.parameters={...S.parameters,__id:n,globals:t.globals,globalTypes:t.globalTypes,args:S.initialArgs,argTypes:S.argTypes});let Nr=async p=>{let f=await Promise.all(g.map(A=>A(p))),T=Object.assign({},...f);return{...p,loaded:T}},mr=p=>{let f=Object.entries(p.args).reduce((P,[I,E])=>{let O=p.argTypes[I]?.mapping;return P[I]=O&&E in O?O[E]:E,P},{}),T=Object.entries(f).reduce((P,[I,E])=>{let O=p.argTypes[I]||{};return ge(O,f,p.globals)&&(P[I]=E),P},{}),A={...p,args:T},{passArgsFirst:Dr=!0}=p.parameters;return Dr?h(A.args,A):h(A)},Rr=Sr(l)(mr,m),Br=p=>{let f=p;if(hr.FEATURES?.argTypeTargetsV7){let T=q(p);f={...p,allArgs:p.args,argsByTarget:T,args:T[B]||{}}}return Rr(f)},{play:yr}=e;return Object.freeze({...S,moduleExport:o,originalStoryFn:h,undecoratedStoryFn:mr,unboundStoryFn:Br,applyLoaders:Nr,playFunction:yr&&(async p=>{let f={...p,step:(T,A)=>u(T,A,f)};return yr(f)})})}import X from\"lodash/mapValues\";import{dedent as Fe}from\"ts-dedent\";import{logger as he}from\"@storybook/client-logger\";var rr=(e,r,t)=>{let o=typeof e;switch(o){case\"boolean\":case\"string\":case\"number\":case\"function\":case\"symbol\":return{name:o};default:break}if(e){if(t.has(e))return he.warn(Fe`\n        We've detected a cycle in arg '${r}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `),{name:\"other\",value:\"cyclic object\"};if(t.add(e),Array.isArray(e)){let s=e.length>0?rr(e[0],r,new Set(t)):{name:\"other\",value:\"unknown\"};return{name:\"array\",value:s}}let n=X(e,s=>rr(s,r,new Set(t)));return{name:\"object\",value:n}}return{name:\"object\",value:{}}},er=e=>{let{id:r,argTypes:t={},initialArgs:o={}}=e,n=X(o,(i,a)=>({name:a,type:rr(i,`${r}.${a}`,new Set)})),s=X(t,(i,a)=>({name:a}));return F(n,s,t)};er.secondPass=!0;import Ae from\"lodash/mapValues\";import{logger as be}from\"@storybook/client-logger\";import Te from\"lodash/pickBy\";var Tr=(e,r)=>Array.isArray(r)?r.includes(e):e.match(r),tr=(e,r,t)=>!r&&!t?e:e&&Te(e,(o,n)=>{let s=o.name||n;return(!r||Tr(s,r))&&(!t||!Tr(s,t))});var we=(e,r,t)=>{let{type:o,options:n}=e;if(!!o){if(t.color&&t.color.test(r)){let s=o.name;if(s===\"string\")return{control:{type:\"color\"}};s!==\"enum\"&&be.warn(`Addon controls: Control of type color only supports string, received \"${s}\" instead`)}if(t.date&&t.date.test(r))return{control:{type:\"date\"}};switch(o.name){case\"array\":return{control:{type:\"object\"}};case\"boolean\":return{control:{type:\"boolean\"}};case\"string\":return{control:{type:\"text\"}};case\"number\":return{control:{type:\"number\"}};case\"enum\":{let{value:s}=o;return{control:{type:s?.length<=5?\"radio\":\"select\"},options:s}}case\"function\":case\"symbol\":return null;default:return{control:{type:n?\"select\":\"object\"}}}}},V=e=>{let{argTypes:r,parameters:{__isArgsStory:t,controls:{include:o=null,exclude:n=null,matchers:s={}}={}}}=e;if(!t)return r;let i=tr(r,o,n),a=Ae(i,(m,l)=>m?.type&&we(m,l,s));return F(a,i)};V.secondPass=!0;function L({argTypes:e,globalTypes:r,argTypesEnhancers:t,...o}){return{...e&&{argTypes:w(e)},...r&&{globalTypes:w(r)},argTypesEnhancers:[...t||[],er,V],...o}}function Ar(e){return async(r,t,o)=>{await e.reduceRight((s,i)=>async()=>i(r,s,o),async()=>t(o))()}}function j(e,r){return e.map(t=>t[r]).filter(Boolean)}function W(e,r){return j(e,r).reduce((t,o)=>[...t,...o],[])}function H(e,r){return Object.assign({},...j(e,r))}function or(e,r){return j(e,r).pop()}function br(e){let r=W(e,\"argTypesEnhancers\"),t=j(e,\"runStep\");return{parameters:F(...j(e,\"parameters\")),decorators:W(e,\"decorators\"),args:H(e,\"args\"),argsEnhancers:W(e,\"argsEnhancers\"),argTypes:H(e,\"argTypes\"),argTypesEnhancers:[...r.filter(o=>!o.secondPass),...r.filter(o=>o.secondPass)],globals:H(e,\"globals\"),globalTypes:H(e,\"globalTypes\"),loaders:W(e,\"loaders\"),render:or(e,\"render\"),renderToDOM:or(e,\"renderToDOM\"),applyDecorators:or(e,\"applyDecorators\"),runStep:Ar(t)}}import{isExportStory as xe}from\"@storybook/csf\";var wr={};function wo(e){let r=Array.isArray(e)?e:[e];wr=br(r)}function xo(e,r,t=wr,o={},n){if(e===void 0)throw new Error(\"Expected a story but received undefined.\");r.title=r.title??\"ComposedStory\";let s=_(r),i=n||e.storyName||e.story?.name||e.name||\"unknown\",a=M(i,e,s),m=L({...t,...o}),l=$(a,s,m),d=C(t.globalTypes),y=u=>{let g={...l,hooks:new v,globals:d,args:{...l.initialArgs,...u}};return l.unboundStoryFn(g)};return y.storyName=i,y.args=l.initialArgs,y.play=l.playFunction,y.parameters=l.parameters,y}function ko(e,r,t){let{default:o,__esModule:n,__namedExportsOrder:s,...i}=e;return Object.entries(i).reduce((m,[l,d])=>xe(l,o)?Object.assign(m,{[l]:t(d,o,r,l)}):m,{})}var Ce=1e3,Pe=1e4,sr=class{constructor(){this.getStoriesJsonData=()=>{let{storyIndex:r}=this;if(!r)throw new Error(\"getStoriesJsonData called before initialization\");let t=this.getSetStoriesPayload(),o=[\"fileName\",\"docsOnly\",\"framework\",\"__id\",\"__isArgsStory\"],n=ke(t.stories,s=>{let{importPath:i}=r.entries[s.id];return{...kr(s,[\"id\",\"name\",\"title\"]),importPath:i,kind:s.title,story:s.name,parameters:{...kr(s.parameters,o),fileName:i}}});return{v:3,stories:n}};this.args=new D,this.hooks={},this.processCSFFileWithCache=xr(Ce)(gr),this.prepareStoryWithCache=xr(Pe)($),this.initializationPromise=new nr(r=>{this.resolveInitializationPromise=r})}setProjectAnnotations(r){this.projectAnnotations=L(r);let{globals:t,globalTypes:o}=r;this.globals?this.globals.set({globals:t,globalTypes:o}):this.globals=new G({globals:t,globalTypes:o})}initialize({storyIndex:r,importFn:t,cache:o=!1}){return this.storyIndex=new z(r),this.importFn=t,this.resolveInitializationPromise(),o?this.cacheAllCSFFiles():nr.resolve()}async onStoriesChanged({importFn:r,storyIndex:t}){await this.initializationPromise,r&&(this.importFn=r),t&&(this.storyIndex.entries=t.entries),this.cachedCSFFiles&&await this.cacheAllCSFFiles()}async storyIdToEntry(r){return await this.initializationPromise,this.storyIndex.storyIdToEntry(r)}loadCSFFileByStoryId(r){if(!this.storyIndex||!this.importFn)throw new Error(\"loadCSFFileByStoryId called before initialization\");let{importPath:t,title:o}=this.storyIndex.storyIdToEntry(r);return this.importFn(t).then(n=>this.processCSFFileWithCache(n,t,o))}loadAllCSFFiles(){if(!this.storyIndex)throw new Error(\"loadAllCSFFiles called before initialization\");let r={};Object.entries(this.storyIndex.entries).forEach(([o,{importPath:n}])=>{r[n]=o});let t=Object.entries(r).map(([o,n])=>this.loadCSFFileByStoryId(n).then(s=>({importPath:o,csfFile:s})));return nr.all(t).then(o=>o.reduce((n,{importPath:s,csfFile:i})=>(n[s]=i,n),{}))}cacheAllCSFFiles(){return this.initializationPromise.then(()=>this.loadAllCSFFiles().then(r=>{this.cachedCSFFiles=r}))}async loadStory({storyId:r}){await this.initializationPromise;let t=await this.loadCSFFileByStoryId(r);return this.storyFromCSFFile({storyId:r,csfFile:t})}storyFromCSFFile({storyId:r,csfFile:t}){if(!this.projectAnnotations)throw new Error(\"storyFromCSFFile called before initialization\");let o=t.stories[r];if(!o)throw new Error(`Didn't find '${r}' in CSF file, this is unexpected`);let n=t.meta,s=this.prepareStoryWithCache(o,n,this.projectAnnotations);return this.args.setInitial(s),this.hooks[s.id]=this.hooks[s.id]||new v,s}componentStoriesFromCSFFile({csfFile:r}){if(!this.storyIndex)throw new Error(\"componentStoriesFromCSFFile called before initialization\");return Object.keys(this.storyIndex.entries).filter(t=>!!r.stories[t]).map(t=>this.storyFromCSFFile({storyId:t,csfFile:r}))}async loadEntry(r){let t=await this.storyIdToEntry(r),{importFn:o,storyIndex:n}=this;if(!n||!o)throw new Error(\"loadEntry called before initialization\");let s=t.type===\"docs\"?t.storiesImports:[],[i,...a]=await Promise.all([o(t.importPath),...s.map(m=>{let l=n.importPathToEntry(m);return this.loadCSFFileByStoryId(l.id)})]);return{entryExports:i,csfFiles:a}}getStoryContext(r){if(!this.globals)throw new Error(\"getStoryContext called before initialization\");return{...r,args:this.args.get(r.id),globals:this.globals.get(),hooks:this.hooks[r.id]}}cleanupStory(r){this.hooks[r.id].clean()}extract(r={includeDocsOnly:!1}){if(!this.storyIndex)throw new Error(\"extract called before initialization\");let{cachedCSFFiles:t}=this;if(!t)throw new Error(\"Cannot call extract() unless you call cacheAllCSFFiles() first.\");return Object.entries(this.storyIndex.entries).reduce((o,[n,{type:s,importPath:i}])=>{if(s===\"docs\")return o;let a=t[i],m=this.storyFromCSFFile({storyId:n,csfFile:a});return!r.includeDocsOnly&&m.parameters.docsOnly||(o[n]=Object.entries(m).reduce((l,[d,y])=>d===\"moduleExport\"||typeof y==\"function\"?l:Array.isArray(y)?Object.assign(l,{[d]:y.slice().sort()}):Object.assign(l,{[d]:y}),{args:m.initialArgs})),o},{})}getSetStoriesPayload(){if(!this.globals)throw new Error(\"getSetStoriesPayload called before initialization\");let r=this.extract({includeDocsOnly:!0}),t=Object.values(r).reduce((o,{title:n})=>(o[n]={},o),{});return{v:2,globals:this.globals.get(),globalParameters:{},kindParameters:t,stories:r}}getSetIndexPayload(){if(!this.storyIndex)throw new Error(\"getSetIndexPayload called before initialization\");let r=this.extract({includeDocsOnly:!0});return{v:4,entries:Object.fromEntries(Object.entries(this.storyIndex.entries).map(([t,o])=>[t,r[t]?{...o,args:r[t].initialArgs,initialArgs:r[t].initialArgs,argTypes:r[t].argTypes,parameters:r[t].parameters}:o]))}}raw(){return Object.values(this.extract()).map(({id:r})=>this.fromId(r)).filter(Boolean)}fromId(r){if(!this.storyIndex)throw new Error(\"fromId called before initialization\");if(!this.cachedCSFFiles)throw new Error(\"Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.\");let t;try{({importPath:t}=this.storyIndex.storyIdToEntry(r))}catch{return null}let o=this.cachedCSFFiles[t],n=this.storyFromCSFFile({storyId:r,csfFile:o});return{...n,storyFn:s=>{let i={...this.getStoryContext(n),viewMode:\"story\"};return n.unboundStoryFn({...i,...s})}}}};import ir from\"slash\";import{dedent as Ie}from\"ts-dedent\";import{once as Ee}from\"@storybook/client-logger\";var Oe=e=>{let r=[...e],t=r[r.length-1],o=t.indexOf(\".\"),n=o>0?t.substr(0,o):t;r[r.length-1]=n;let[s,...i]=r;return s===\"\"&&(r=i),r},je=/^index$/i,ze=e=>{let r;return e.filter((t,o)=>o===e.length-1&&(t===r||je.test(t))?!1:(r=t,!0))};function Cr(e){let r=new RegExp(\"/{1,}\",\"g\");return e.join(\"/\").replace(r,\"/\")}var Ne=(e,r,t)=>{let{directory:o,importPathMatcher:n,titlePrefix:s=\"\"}=r||{};typeof e==\"number\"&&Ee.warn(Ie`\n      CSF Auto-title received a numeric fileName. This typically happens when\n      webpack is mis-configured in production mode. To force webpack to produce\n      filenames, set optimization.moduleIds = \"named\" in your webpack config.\n    `);let i=ir(String(e));if(n.exec(i)){if(!t){let a=i.replace(o,\"\"),l=ir(Cr([s,a])).split(\"/\");return l=Oe(l),l=ze(l),l.join(\"/\")}return s?ir(Cr([s,t])):t}},$o=(e,r,t)=>{for(let o=0;o<r.length;o+=1){let n=Ne(e,r[o],t);if(n)return n}return t||void 0};import{dedent as Re}from\"ts-dedent\";var Pr=/\\s*\\/\\s*/,Ir=(e={})=>(r,t)=>{if(r.title===t.title&&!e.includeNames)return 0;let o=e.method||\"configure\",n=e.order||[],s=r.title.trim().split(Pr),i=t.title.trim().split(Pr);e.includeNames&&(s.push(r.name),i.push(t.name));let a=0;for(;s[a]||i[a];){if(!s[a])return-1;if(!i[a])return 1;let m=s[a],l=i[a];if(m!==l){let y=n.indexOf(m),u=n.indexOf(l),g=n.indexOf(\"*\");return y!==-1||u!==-1?(y===-1&&(g!==-1?y=g:y=n.length),u===-1&&(g!==-1?u=g:u=n.length),y-u):o===\"configure\"?0:m.localeCompare(l,e.locales?e.locales:void 0,{numeric:!0,sensitivity:\"accent\"})}let d=n.indexOf(m);d===-1&&(d=n.indexOf(\"*\")),n=d!==-1&&Array.isArray(n[d+1])?n[d+1]:[],a+=1}return 0};var Or=(e,r,t)=>{if(r){let o;typeof r==\"function\"?o=r:o=Ir(r),e.sort(o)}else e.sort((o,n)=>t.indexOf(o.importPath)-t.indexOf(n.importPath));return e},Uo=(e,r,t)=>{try{return Or(e,r,t)}catch(o){throw new Error(Re`\n    Error sorting stories with sort parameter ${r}:\n\n    > ${o.message}\n    \n    Are you using a V6-style sort function in V7 mode?\n\n    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n  `)}},Er=e=>{let{id:r,title:t,name:o,parameters:n,type:s}=e;return{id:r,title:t,name:o,importPath:n.fileName,type:s}},Jo=(e,r,t)=>{if(r&&typeof r==\"function\")return e.sort(r),e.map(n=>Er(n[1]));let o=e.map(n=>Er(n[1]));return Or(o,r,t)};export{b as DEEPLY_EQUAL,v as HooksContext,B as NO_TARGET_NAME,sr as StoryStore,Sr as applyHooks,R as combineArgs,F as combineParameters,br as composeConfigs,Ar as composeStepRunners,ko as composeStories,xo as composeStory,pe as decorateStory,k as deepDiff,Fr as defaultDecorateStory,tr as filterArgTypes,W as getArrayField,j as getField,H as getObjectField,or as getSingletonField,C as getValuesFromArgTypes,q as groupArgsByTarget,V as inferControls,pr as mapArgsToTypes,Le as noTargetArgs,_ as normalizeComponentAnnotations,Yr as normalizeInputType,w as normalizeInputTypes,L as normalizeProjectAnnotations,M as normalizeStory,$ as prepareStory,gr as processCSFFile,de as sanitizeStoryContextUpdate,wo as setProjectAnnotations,Jo as sortStoriesV6,Uo as sortStoriesV7,Ct as useAddonState,xt as useArgs,ht as useCallback,ye as useChannel,me as useEffect,kt as useGlobals,ae as useMemo,wt as useParameter,At as useReducer,Tt as useRef,ce as useSharedState,le as useState,bt as useStoryContext,$o as userOrAutoTitle,Ne as userOrAutoTitleFromSpecifier,dr as validateOptions};\n"],"names":[],"sourceRoot":""}